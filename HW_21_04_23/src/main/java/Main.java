/**
 * Необходимо смоделировать библиотеку. Для каждой книги библиотечного фонда известны автор, название и год издания.
 * Для читателя библиотеки будем хранить ФИО и электронный адрес (объекты типа EmailAddress).
 * Каждый читатель может взять в библиотеке одну или несколько книг - их тоже сохраним.
 * Ещё нам понадобится флаг читательского согласия на уведомления по электронной почте.
 * Рассылки организуют сотрудники библиотеки: напоминают о сроке возврата книг, сообщают новости.
 * Разработайте соответствующие классы.
 * Task 1. Получить список всех книг библиотеки, отсортированных по году издания.
 * Task 2. Требуется создать список рассылки (объекты типа EmailAddress) из адресов всех читателей библиотеки.
 * При этом флаг согласия на рассылку учитывать не будем: библиотека закрывается, так что хотим оповестить всех.
 * Task 3. Снова нужно получить список рассылки. Но на этот раз включаем в него только адреса читателей,
 * которые согласились на рассылку. Дополнительно нужно проверить, что читатель взял из библиотеки больше одной книги.
 * Task 4. Получить список всех книг, взятых читателями. Список не должен содержать дубликатов (книг одного автора,
 * с одинаковым названием и годом издания).
 * Task 5. Проверить, взял ли кто-то из читателей библиотеки какие-нибудь книги Оруэлла.
 * Task 6. Узнать наибольшее число книг, которое сейчас на руках у читателя.
 * Task 7*. Вернёмся к нашим email-рассылкам. Теперь нужно не просто отправить письма всем, кто согласился на рассылку,
 * — будем рассылать разные тексты двум группам:
 *
 *
 * тем, у кого взято меньше двух книг, просто расскажем о новинках библиотеки;
 *
 * тем, у кого две книги и больше, напомним о том, что их нужно вернуть в срок.
 * То есть надо написать метод, который вернёт два списка адресов (типа EmailAddress): с пометкой OK — если книг не больше двух,
 * или TOO_MUCH — если их две и больше. Порядок групп не важен.
 *
 *
 * Можно решить любое количество задач. Все задачи будем разбирать на занятии.
 * Единственное условие: попробуйте решить все задачи с помощью Stream API.
 */

public class Main {
    public static void main(String[] args) {

    }
    /*
readerList.stream()
        .collect(Collectors.groupingBy(
            x->x.getBookList().size()<2?"OK":"TOO MUCH",
            Collectors.mapping(Reader::getEmail, Collectors.toList())
            ));
*/
}
